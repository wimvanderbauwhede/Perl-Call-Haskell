package Call::Haskell::FFIGenerator;
use warnings;
use strict;
use v5.16;

use Cwd;
use Digest::MD5;

use version; our $VERSION = version->declare('v0.0.1');

use Exporter 'import';

@Call::Haskell::FFIGenerator::EXPORT = qw(
  create_hs_ffi_generator
);

# This module generates all the glue code needed for calling Haskell from Perl.
# What we should do is test if the original module has changed via a checksum
our $VV=0;
sub create_hs_ffi_generator {
 ( my $module_name, my $function_names, my $inc, my $CLEAN, my $VV, my $perl_types ) = @_;
 $Call::Haskell::FFIGenerator::VV=$VV;
 my $wd = cwd();
 if ( not -e '_Call_Haskell' ) {
  mkdir '_Call_Haskell';
 }
 chdir '_Call_Haskell';
 my $generate = 0;
 if ( $CLEAN == 1 ) {
  say "CLEANING generated sources" if $VV;
  unlink $module_name . '_ffi_wrapper_gen.hs';
  unlink $module_name . "FFIWrapper.hs";
  unlink $module_name . "CWrapper.c";
  unlink $module_name . "CWrapper.h";    
  $generate = 1;
 }
 else {
  #  say "Computing MD5";
  my $filename = "$wd/$inc/$module_name.hs";
  open( my $fh, '<', $filename ) or die "Can't open '$filename': $!";
  binmode($fh);
  my $md5 = Digest::MD5->new;
  while (<$fh>) {
   $md5->add($_);
  }
  close($fh);
  my $checksum = $md5->hexdigest;
  if ( -e "$module_name.md5" ) {
   open( my $md5fh, '<', "$module_name.md5" );
   my $ref_checksum = <$md5fh>;
   close $md5fh;
   say "MD5:", $checksum eq $ref_checksum if $VV;
   if ( $checksum ne $ref_checksum ) {
    unlink "$module_name.md5";
    $generate = 1;
   }
   else {
    $generate = 0;
   }
  }
  else {
   $generate = 1;
  }
  if ( not -e "$module_name.md5" ) {
   $generate = 1;
   open( my $md5fh, '>', "$module_name.md5" );
   print $md5fh $checksum;
   close $md5fh;
  }
 }
 if (
  not( -e $module_name . '_ffi_wrapper_gen.hs'
   and -e $module_name . "FFIWrapper.hs"
   and -e $module_name . "CWrapper.c"
   and -e $module_name . "CWrapper.h"
   and -e $module_name . "_Inline_C.c" )
   )
 {
  $generate = 1;
 }
my $c_code='';
 if ( $generate == 1 ) {

  my $hs_module_dir = $inc;

  open my $GEN, '>', "${module_name}_ffi_wrapper_gen.hs";
  say $GEN "-- Code generated by $0 on " . scalar localtime;
  while ( my $line = <DATA> ) {
   if ( $line =~ /_MODULE_NAME_/ ) {
    $line =~ s/_MODULE_NAME_/$module_name/;
   }
   if ( $line =~ /_FUNC_/ ) {
    my $nlines = '';
    for my $function_name ( @{$function_names} ) {
     my $nline = $line;
     $nline =~ s/_FUNC_/$function_name/g;
     $nlines .= $nline;
    }
    $nlines =~ s/\,$//;
    $line = $nlines;
   }
   print $GEN $line;
  }
  close DATA;
  close $GEN;
 my $Call_Haskell_path=$INC{"Call/Haskell/FFIGenerator.pm"};
 my $hs_FFIGenerator_dir=$Call_Haskell_path;
 $hs_FFIGenerator_dir=~s/Call.Haskell.FFIGenerator.pm$//;
 if ($hs_FFIGenerator_dir=~/^\./) {die "\nThe path to the Call::Haskell module _must_ be absolute, please redefine your PERL5LIB\n\n"; } 
 say  "FFIGenerator path:",$hs_FFIGenerator_dir if $VV;   
   my @hs_f_types =
    `runhaskell -i$wd/$hs_module_dir -i$hs_FFIGenerator_dir ${module_name}_ffi_wrapper_gen.hs`;
   $c_code = create_C_wrapper( \@hs_f_types, $module_name );
 
  open my $INL_C_CODE, '>', $module_name . '_Inline_C.c';
  print $INL_C_CODE $c_code;
  close $INL_C_CODE;
  my @decomp_hs_types = map { decomposeHSType($_) } @hs_f_types;
#  say Dumper(@hs_f_types);
#  die Dumper(@decomp_hs_types);
  mkdir "$wd/_Call_Haskell/CallHaskellWrappers";
  for my $ft (@decomp_hs_types) {
   (my $fn, my $arg_types, my $ret_type)=@{$ft};
   if(isSimpleSig(@{$arg_types}, $ret_type)==0) {   
      if (not -e "$wd/_Call_Haskell/CallHaskellWrappers/$fn.pm")  {
       # create the sub       
       my $code = <<"ENDWC";
package CallHaskellWrappers::$fn;
use Exporter qw( import );
\@CallHaskellWrappers::${fn}::EXPORT = qw( $fn );

ENDWC
       
       if ($perl_types eq '') {
       my $hs_argtup_type = (scalar @{$arg_types} > 1) ?  '('.join(',',@{$arg_types}).')' : $arg_types->[0];
        
        $code .= <<"ENDWH";
use Call::Haskell::ReadShow qw( showH readH );
require Call::Haskell; 
sub $fn {
    my \$hs_type='$hs_argtup_type';
    my \$in_str = Call::Haskell::ReadShow::showH(\@_,\$hs_type);
    my \$out_str=Call::Haskell::${fn}_ser(\$in_str);
    my \$res = Call::Haskell::ReadShow::readH(\$out_str);
    return \$res;
}

ENDWH
        
       } else {

       $code .= <<"ENDWTP";
use Types;
use $perl_types;
require Call::Haskell; 
sub $fn {
    my \$in_str = Types::show(\@_);
    my \$out_str=Call::Haskell::${fn}_ser(\$in_str);
    my \$res = Types::read(\$out_str);
    return \$res;
}

ENDWTP

$code .= "1;\n";
       }
open my $SUB,'>',"$wd/_Call_Haskell/CallHaskellWrappers/$fn.pm";
print $SUB $code;
close $SUB;
      }
   }
    }   
 }
 else {
  say "NO GENERATION NECESSARY!" if $VV;
  open my $INL_C_CODE, '<', $module_name . '_Inline_C.c';
  while ( my $line = <$INL_C_CODE> ) {
   $c_code .= $line;
  }
  close $INL_C_CODE;
 }
 
 return ( $c_code, $generate );
}

my %SimpleTypes =
  map { ( $_ => 1, "IO $_" => 1 ) }
  qw( Int Integer Float Double String [Char] );

sub HstoP_types {
 ( my $hs_t, my $is_retval ) = @_;
 my $p_t = 'NONE';
 if ( $hs_t eq 'Int' ) {
  $p_t = 'long';
 }
 elsif ( $hs_t eq 'Double' ) {
  $p_t = 'double';

 }
 elsif ( $hs_t eq '[Char]' or $hs_t eq 'String' ) {
  if ($is_retval) {
   $p_t = 'SV*'
     ; # SvPV(sv_name, PL_na)  char* n_c_str = newSVpvf("STR: <%s %s> OK\n", c_str,hs_str);
  }
  else {
   $p_t = 'char*';
  }
 }
 else {

  # This type needs to be serialised, so it's a string
  # This is not correct on a per-arg basis, but we should not come here
  if ($is_retval) {
   $p_t = 'SV*'
     ; # SvPV(sv_name, PL_na)  char* n_c_str = newSVpvf("STR: <%s %s> OK\n", c_str,hs_str);
  }
  else {
   $p_t = 'char*';
  }
 }
 return $p_t;
}

sub isSimpleSig {
 ( my @hs_f_types ) = @_;
 my $test = 1;
 map { $test = $test && ( exists $SimpleTypes{$_} ? 1 : 0 ) }
   @hs_f_types  ;#( @{$argtypes}, $ret_type );
# say "isSimpleSig <$test>";
 return $test;
}

sub decomposeHSType {
 ( my $hs_f_type ) = @_;
# say "decomposeHSType:",$hs_f_type;
 chomp $hs_f_type;
 ( my $f, my $args ) = split( /\s+::\s+/, $hs_f_type );
 my @argtypes = split( /\s+->\s+/, $args );
 my $ret_type = pop @argtypes;
 my $res= [ $f, \@argtypes, $ret_type ];
# say Dumper($res);
 return $res;
}

sub create_C_wrapper {
 ( my $hs_f_types, my $module_name ) = @_;
 my $inc    = '#include "' . $module_name . 'CWrapper.h"';
 my $date   = scalar localtime;
 my $c_code = "// Code generated by $0 on $date
$inc
int hs_begin(int n) {
    hs_${module_name}_init();
    return n;
}

int hs_end(int n) {
    hs_${module_name}_end();
    return n;
}
";
 my $ws = '    ';
 for my $hs_f_type ( @{$hs_f_types} ) {
  ( my $f, my $argtypes, my $res_t ) = @{&decomposeHSType($hs_f_type)};
  
#  say "TYPE: $hs_f_type";
#  say "DECTYPE:", Dumper($argtypes);
#  say $f;
  my @fdef_lines = do {

   if ( isSimpleSig(@{$argtypes}, $res_t) == 1 ) {
    say "SIMPLE!" if $VV;
    my $i = 0;
    (
     '',
     HstoP_types( $res_t, 1 ) . " $f("
       . join( ',', map { HstoP_types( $_, 0 ) . ' x' . ++$i } @{$argtypes} )
       . ') {',

     #            $ws.'printf("BEFORE FFI CALL\n");',
     $ws
       . HstoP_types( $res_t, 0 )
       . " res = ${f}_ffi_c("
       . join( ', ', map { "x$_" } ( 1 .. $i ) ) . ');',

     #            $ws.'printf("AFTER FFI CALL\n");',
     $ws 
       . HstoP_types( $res_t, 0 ) 
       . ' nres = '
       . (
      ( $res_t eq '[Char]' or $res_t eq 'String' ) ? 'newSVpv(res,0);' : 'res;'
       ),

     $ws . 'return nres;',
     '}',
     ''
    );
   }
   else {
    say "SERIALISE!" if $VV;
    (
     '',
     "SV* ${f}_ser(char* sstr) {",
     $ws . "char* res = ${f}_ffi_c(sstr);",
     $ws . 'SV* nres = newSVpv(res,0);',
     $ws . 'return nres;',
     '}', ''
    );
   }
  };

  my $fdef = join( "\n", @fdef_lines );

  #    print $fdef;
  $c_code .= $fdef;
 }
 return $c_code;
} # END of create_C_wrapper()

1;

# _FUNC_ gets populated for every function with magic commas

__DATA__
module Main where
import Data.Typeable ( typeOf )
-- import Data.List ( intercalate )
import FFIGenerator.GetTypes ( getFFITypes, hasSimpleSig, getTypes )
import FFIGenerator.GenerateCode ( createHaskellWrapper, createCWrapper, createCWrapperHeader )

import _MODULE_NAME_ ( 
        _FUNC_,
        )

module_name = "_MODULE_NAME_"
func_list =[
    ("_FUNC_", getFFITypes _FUNC_ , hasSimpleSig _FUNC_ , getTypes _FUNC_ ),
  ]

-- So this generated module provides module_name and func_list 
-- To do so, it requires getFFITypes and hasSimpleSig from FFIGenerator.GetTypes
-- The functions that generate the code can go in FFIGenerator.GenerateCode
 
main = do
    createHaskellWrapper module_name func_list
    createCWrapper module_name func_list
    createCWrapperHeader module_name func_list
    putStrLn $ "_FUNC_ :: "++(show(typeOf _FUNC_))
--    mapM (\(f,ffit,fs,ft) -> putStrLn (f++" :: "++ (intercalate " -> " ft))) func_list

